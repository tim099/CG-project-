#include "class/tim/string/String.h"
#include "class/texture/texture.h"
#include "class/buffer/Buffer.h"
#include "class/model/Vertex.h"
#include <cstdio>
#include <iostream>
#include <cmath>
#include <cstring>
#include <GL/glfw3.h>
Texture::Texture() {
	TexID=0;
}
Texture::~Texture() {
	glDeleteTextures(1,&TexID);
}
void Texture::convert_to_sobel(Image* image){
	int col;
	for(unsigned i=0;i<image->imageSize/3;i++){// convert to grey
		col=(((int)image->data[3*i]+(int)image->data[3*i+1]+(int)image->data[3*i+2])/3);
		image->data[3*i]=(unsigned char)col;
		image->data[3*i+1]=(unsigned char)col;
		image->data[3*i+2]=(unsigned char)col;
	}
	unsigned char arr[3][3];
	for(unsigned i=0;i<image->height;i++){
		for(unsigned j=0;j<image->width;j++){
			for(int l=0;l<3;l++){
				for(int m=0;m<3;m++){
					int x=j+m-1,y=i+l-1;
					if(x<0||y<0||x>=(int)image->width||y>=(int)image->height){
						arr[l][m]=0;
					}else{
						arr[l][m]=image->data[(x+y*image->width)*3];
					}
				}
			}
			int GX=-1*arr[0][0]+arr[0][2]-2*arr[1][0]+2*arr[1][2]-1*arr[2][0]+arr[2][2];
			int GY=-1*arr[0][0]+arr[2][0]-2*arr[0][1]+2*arr[2][1]-1*arr[0][2]+arr[2][2];
			int value=sqrt(GX*GX+GY*GY);

			image->data[3*(j+i*image->width)+2]=(unsigned char)(value<255?value:255);
		}
	}
	for(unsigned i=0;i<image->imageSize/3;i++){//convert to BMP
		image->data[3*i]=image->data[3*i+2];
		image->data[3*i+1]=image->data[3*i+2];
	}
}
Texture* Texture::loadBMP_to_sobel(const char * imagepath,int Parameteri){
	Image* bmp=new Image();
	bmp->loadBMP(imagepath);
	convert_to_sobel(bmp);
	Texture* texture=gen_texture(bmp,GL_RGB,GL_UNSIGNED_BYTE,Parameteri);//BMP is BGR Format
	return texture;
}
Texture* Texture::loadBMP(const char * imagepath,int Parameteri){
	Image* bmp_img=new Image();
	bmp_img->loadBMP(imagepath);
	Texture* texture=gen_texture(bmp_img,GL_RGB,GL_UNSIGNED_BYTE,Parameteri);//BMP is BGR Format
	delete bmp_img;
	return texture;
}
Texture* Texture::gen_texture(Image* image,GLint internalformat,GLenum type,int Parameteri){
	return gen_texture(image->data,image->width,image->height,internalformat,image->format,type,Parameteri);
}
Texture* Texture::gen_texture(const void *pixels,GLsizei width,GLsizei height,GLint internalformat,GLenum format,GLenum type,int Parameteri){
	GLuint textureID;
	glGenTextures(1,&textureID);
	glBindTexture(GL_TEXTURE_2D,textureID);
	glTexImage2D(GL_TEXTURE_2D,0,internalformat,width,height,0,format,type,pixels);
	switch(Parameteri){
		case P_NONE:
			break;
		case P_MipMap:
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
			glGenerateMipmap(GL_TEXTURE_2D);
			break;
		case P_Linear:
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);//GL_NEAREST
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);//GL_NEAREST
			break;
		case P_Nearest:
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
			break;
		default:
			std::cout<<"err unknow texture Parameteri type:"<<Parameteri<<std::endl;

	}
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);//GL_CLAMP
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	Texture *tex=new Texture;
	tex->TexID=textureID;
	return tex;
}
void Texture::usetextureArr(GLuint programID,Texture* texArr,int num,int tex_num,const char *name){
	int slen=strlen(name);
	char temp[100];
	for(int i=0;i<slen;i++){
		temp[i]=name[i];
	}
	for(int i=0;i<tex_num;i++){
		Tim::String::gen_array_num(temp+slen,i);
		usetexture(programID,&texArr[i],i+num,temp);
	}
}
void Texture::usetexture(GLuint programID,Texture* tex,int num,const char *name,GLenum target){
	glUniform1i(glGetUniformLocation(programID,name),num);//texturebuffer
	glActiveTexture(GL_TEXTURE0+num);
	glBindTexture(target,tex->TexID);//GL_TEXTURE_CUBE_MAP
}
GLuint Texture::gen_texture_vertex(GLfloat width,GLfloat height,glm::vec3 pos){
	GLfloat vertex_buffer_data[18];
	Vertex::gen_quad_vt(vertex_buffer_data,pos,glm::vec3(width,height,0));
	return Buffer::gen_buffer(vertex_buffer_data,sizeof(vertex_buffer_data));
}
void Texture::draw_texture(Texture* tex,GLuint shader2D,double winaspect,double texaspect,GLfloat alpha,glm::vec3 pos
		,double size){
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
	glDisable(GL_DEPTH_TEST);

    GLuint tex_vertex=0;
	if(winaspect==texaspect){
		tex_vertex=gen_texture_vertex(1.0,1.0);
	}else{
		float height=1.0;
		double aspect=winaspect/texaspect;
		if(aspect>1.0)height=1.0/aspect;
		tex_vertex=gen_texture_vertex(height,height*aspect);
	}
	Buffer::bind_vtbuffer(tex_vertex);
	Texture::usetexture(shader2D,tex,0,"myTextureSampler");
	glUniform3f(glGetUniformLocation(shader2D,"position"),pos.x,pos.y,pos.z);
	glUniform1f(glGetUniformLocation(shader2D,"size"),size);
	glUniform1f(glGetUniformLocation(shader2D,"alpha"),alpha);
	glDrawArrays(GL_TRIANGLES,0,2*3);
    glDeleteBuffers(1,&tex_vertex);
    glDisableVertexAttribArray(0);//vertexbuffer
    glEnable(GL_DEPTH_TEST);
    glDisable(GL_BLEND);
}
